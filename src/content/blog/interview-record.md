---
author: chou401
pubDatetime: 2024-01-30T12:28:25Z
modDatetime: 2024-05-14T09:37:15Z
title: 面基记录
featured: false
draft: false
tags:
  - java
description: 面试经常被问到的问题
---

## Java 中的四种引用类型

Java 中的引用类型分别为**强、软、弱、虚**。

在 Java 中最常见的就是强引用，把一个对系那个赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它始终处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到 JVM 也不会回收。因此强引用时造成 Java 内存泄漏的主要原因之一。例如：Object obj = new Object()。

其次是软引用，对于只有软引用的对象来说，当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收。软引用通话吃那个用在对内存敏感的程序中，作为缓存使用。例如：SoftRefenence softRef = new SoftRefenence()。

然后是弱引用，它比较引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制已运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。可以解决内存泄漏的问题，ThreadLocal 就是基于弱引用解决内存泄漏的问题。例如：WeakRefenence weakRef = new WeakRefenence()。

最后是虚引用，它不能单独使用，必须和引用队列联合使用。虚引用的主要作用是跟踪对系那个被垃圾回收的状态。例如：ReferenceQueue queue = new ReferenceQueue()；PhantomReference phantomRef = new PhantomReference(obj,queue)，不过在开发中，我们用的更多的还是强引用。

## Rocketmq 消息堆积 堆积到哪里

## OpenFeign 如何实现的消息间内部调用 重要

## OpenFeign 如何实现负载均衡 重要

## CAS 原理是什么

## 线程池 内存分配 紧密型如何分配线程数

## spring cloud resource 和 Autowired 什么区别

## Seata 有几种模式 重要

## ap 和 cp 为什么 p 是不可或缺的 重要

## Hashmap 的时间复杂度是多少？如果出现hash 碰撞如何处理？hashmap 最极端的时间复杂度是多少？

## @Transactional 原理 为什么加上这个 就会实现所有数据库操作在一起

## Java 什么操作可以多线程共享一块内存

## Mysql 优化器原理 如何优化的 优化了什么

## 10000 取 10 个数 用什么算法最好

## Arraylist 是不是线程安全的 哪些是线程安全的

ArrayList 不是线程安全的，它是 Java 中的一种动态数组实现，不同步多线程访问时可能会导致不确定的结果或者异常。如果需要在多线程环境下使用列表，应该使用线程安全的集合类。

Java 提供了几种线程安全的集合类，其中常用的有：

- Vector：Vector 是一个同步的动态数组实现，它的所有方法都使用 synchronized 关键字进行了同步，因此是线程安全的。但是由于同步的开销，性能可能不如 ArrayList。

- Collections.synchronizedList：Collections 类提供了一个静态方法 synchronizedList，可以将任何普通的 List 转换为线程安全的 List。例如：

  ```java
  List<String> synchronizedList = Collections.synchronizedList(new ArrayList<>());
  ```

  使用这种方式，可以获得一个线程安全的 List，但是要注意，虽然它是线程安全的，但在对 List 进行遍历等操作时，仍然需要手动进行同步。

- CopyOnWriteArrayList：CopyOnWriteArrayList 是一个线程安全的并发集合类，它通过在写入操作时创建一个新的拷贝来保证线程安全性，因此读取操作不会受到写入操作的影响。它适用于读操作远远多于写操作的场景。

总的来说，如果在多线程环境下需要使用列表，推荐使用线程安全的集合类，以避免线程安全问题。具体选择哪种线程安全集合类取决于应用程序的需求和性能要求。

## stw 是什么 哪个垃圾回收器 是 stw 时间最少的

STW（Stop-The-World）是一种垃圾回收过程中的一种状态，在这种状态下，应用程序的所有线程都会被暂停，直到垃圾回收完成。STW 时间指的是应用程序被暂停的时间，通常用于衡量垃圾回收器的性能。

在 Java 虚拟机中，不同的垃圾回收器有不同的 STW 时间。一些现代的垃圾回收器，如 G1（Garbage-First）和 ZGC（Z Garbage Collector），在设计上尽可能减少 STW 时间，以提高应用程序的吞吐量和响应性。

G1 垃圾回收器的设计目标之一是尽量减少 STW 时间，以提高应用程序的响应性和吞吐量。通过在多个小区域上执行垃圾收集，并在回收时避免完全暂停整个堆，G1 回收器可以在大多数情况下实现较短的 STW 时间。

目前来说，ZGC 是其中一种 STW 时间最少的垃圾回收器。它是 JDK 11 引入的一种低延迟垃圾回收器，旨在将 STW 时间降到最低，并且可以处理大内存堆。ZGC 的设计目标之一就是尽量将 STW 时间控制在几毫秒以内，以保证应用程序的响应性能。

## 以下内存是如何进行分配的 String s = new String（”12“）string s = ”12“

在Java中，内存分配过程如下：

1. String s = "12"

   - 当执行 String s = "12"; 时，会在字符串常量池中创建一个字符串对象，值为 "12"。
   - 如果字符串常量池中已经存在值为 "12" 的字符串对象，则不会创建新的对象，而是直接将变量 s 指向已存在的对象。
   - 此时，变量 s 指向的是字符串常量池中的字符串对象。

2. String s = new String("12")：- 当执行 String s = new String("12"); 时，会在堆内存中创建一个新的字符串对象，值为 "12"。- 同时，如果字符串常量池中不存在值为 "12" 的字符串对象，则会在字符串常量池中创建一个新的字符串对象，值为 "12"。- 然后，将堆内存中创建的字符串对象的引用赋给变量 s。- 此时，变量 s 指向的是堆内存中的字符串对象。
   总的来说，对于 String s = "12";，变量 s 指向的是字符串常量池中的字符串对象；而对于 String s = new String("12");，变量 s 指向的是堆内存中的字符串对象。在大多数情况下，推荐使用 String s = "12"; 的方式来创建字符串对象，因为它会利用字符串常量池，可以节省内存并提高效率。

## Nacos 注册中心是 ap 还是 cp ，能否 从 ap 切换为 cp

Nacos 注册中心是 AP（可用性和分区容错性）设计的。

Nacos 是一个开源的注册中心和配置中心，它旨在提供服务发现、服务注册、服务健康检查和动态配置管理等功能。Nacos 的设计目标是为了在分布式系统中提供高可用性和可扩展性，因此它更偏向于保证系统的可用性和分区容错性。

在分布式系统中，服务注册中心扮演着关键的角色，它需要保证服务的高可用性，即使发生网络分区也能继续提供服务注册和发现的功能。因此，Nacos 更注重保证系统在分区容错的情况下仍然能够保持可用性，而对一致性要求相对较低。

当然，Nacos 也提供了一些配置选项和策略，以便用户根据自己的需求进行配置和调整。

在分布式系统设计中，通常是通过权衡来选择适当的设计方案。虽然 Nacos 默认是 AP 设计的，但你可以采取一些措施来增加一致性的要求，从而使其更接近 CP 设计。例如：

1. 增加一致性保证的机制：可以通过强制在注册和发现服务时进行数据复制或同步的方式来增加一致性。这样可以确保在发生分区时，系统依然保持一致性。

2. 降低可用性：如果你更加注重一致性，可以通过降低系统的可用性来提高一致性。例如，当发生网络分区时，可以选择不提供服务注册和发现功能，从而保证数据的一致性。

3. 选择合适的一致性级别：Nacos 提供了一些配置选项，可以根据需求选择不同的一致性级别。例如，可以选择强一致性（如使用主从复制）或者最终一致性（如异步复制）来满足特定的一致性要求。

总的来说，虽然 Nacos 默认是 AP 设计的，但在一些特定场景下，你可以通过适当的配置和架构设计来使其更接近 CP 设计。但需要注意的是，增加一致性往往会降低系统的可用性，因此需要权衡设计的各种因素。
